{
  "info": {
    "title": "CodeRoad Redux JS Tutorial",
    "description": "A [CodeRoad](https://coderoad.github.io) tutorial for learning Redux.\n\n<!-- @import('01') -->\n<!-- @import('02') -->\n<!-- @import('03') -->\n<!-- @import('04') -->\n<!-- @import('06') -->\n<!-- @import('07') -->\n<!-- @import('08') -->\n<!-- @import('09') -->"
  },
  "pages": [
    {
      "title": "Pure Functions",
      "description": "Reducers must be pure functions\n\nState is \"read only\".\n\nNotes\n```js\nconst nextPokemon = state.pokemon.map(p => {\n    if (id === p.id) {\n      p.votes += 1;\n    }\n    return p;\n  });\n  return {\n   pokemon: nextPokemon\n };\n ```",
      "tasks": [
        {
          "description": "Return a new list of Pokemon after incrementing \"votes\" of the pokemon with the matching \"id\"",
          "tests": [
            "05/01"
          ]
        },
        {
          "description": "Let's make a test to see that we are truly returning a new state. Wrap your `initialState` object in a `Object.freeze`. Freeze makes an object unchangeable. And yet your reducer should still work.",
          "tests": [
            "05/02"
          ]
        },
        {
          "description": "What if we were dealing with multiple keys on the state. We'd have to ensure that our changes return a complete new state each time. Use `Object.assign`",
          "tests": [
            "05/03"
          ],
          "hints": [
            "return `Object.assign({}, { pokemon: nextPokemon });`"
          ]
        }
      ],
      "onPageComplete": "Now that you have an idea of how reducers work. Next we can look at how to create multiple, modular reducers."
    }
  ]
}